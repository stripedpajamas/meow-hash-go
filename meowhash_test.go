package meowhash

import (
	"bytes"
	"testing"
)

func TestMeowHash1(t *testing.T) {
	L0 := []uint8{0x8, 0x74, 0x51, 0x19, 0x73, 0x4e, 0x62, 0xe1, 0x16, 0xe4, 0x1c, 0x47, 0xa9, 0xd1, 0xa8, 0x3d}
	L1 := []uint8{0xa, 0xa3, 0x86, 0xa8, 0x4e, 0xf3, 0xb2, 0x2d, 0xb, 0x3e, 0x3e, 0x67, 0x59, 0x73, 0x4c, 0x2d}
	L2 := []uint8{0x5c, 0x63, 0xc3, 0xb2, 0xef, 0x40, 0xef, 0x99, 0xc3, 0x76, 0xa0, 0xe5, 0xa3, 0xf5, 0x73, 0x7b}
	L3 := []uint8{0x11, 0x7c, 0x23, 0x91, 0xbd, 0x5c, 0x2a, 0x71, 0xf6, 0x3f, 0xc1, 0xfd, 0xcc, 0x7c, 0xf4, 0xe6}

	data := []byte("Hello World")
	hash := meowHash1(0, data)

	if !bytes.Equal(hash.L0[:], L0) || !bytes.Equal(hash.L1[:], L1) || !bytes.Equal(hash.L2[:], L2) || !bytes.Equal(hash.L3[:], L3) {
		t.Fail()
	}

	// test using the example data in the original implementation
	L0 = []uint8{0xae, 0x42, 0x97, 0x81, 0x54, 0x6d, 0xb4, 0x77, 0x7a, 0x17, 0x28, 0x7f, 0xa2, 0x80, 0x7d, 0x8a}
	L1 = []uint8{0x97, 0x62, 0x93, 0xa3, 0xf8, 0x1f, 0xe5, 0x64, 0x83, 0xe7, 0x1a, 0x17, 0x4f, 0x68, 0x3e, 0xa}
	L2 = []uint8{0xcd, 0x11, 0xe3, 0x49, 0x7b, 0x5f, 0xbc, 0xeb, 0x8f, 0xa1, 0x9e, 0x68, 0x4f, 0xe9, 0x8e, 0x61}
	L3 = []uint8{0x1a, 0xf, 0xf5, 0xa3, 0x5c, 0xc3, 0x6f, 0xb7, 0x60, 0xb4, 0xbc, 0xcc, 0x5d, 0xec, 0x44, 0xe3}
	size := 16000
	data2 := make([]byte, size)
	for i := 0; i < size; i++ {
		data2[i] = byte(i)
	}
	hash = meowHash1(0, data2)

	if !bytes.Equal(hash.L0[:], L0) || !bytes.Equal(hash.L1[:], L1) || !bytes.Equal(hash.L2[:], L2) || !bytes.Equal(hash.L3[:], L3) {
		t.Fail()
	}
}

func TestMeowHash32(t *testing.T) {
	expected := []uint8{0x8, 0x74, 0x51, 0x19}
	data := []byte("Hello World")
	hash := MeowHash32(0, data)
	if !bytes.Equal(hash[:], expected) {
		t.Fail()
	}
}

func TestMeowHash64(t *testing.T) {
	expected := []uint8{0x8, 0x74, 0x51, 0x19, 0x73, 0x4e, 0x62, 0xe1}
	data := []byte("Hello World")
	hash := MeowHash64(0, data)
	if !bytes.Equal(hash[:], expected) {
		t.Fail()
	}
}

func TestMeowHash128(t *testing.T) {
	expected := []uint8{
		0x8, 0x74, 0x51, 0x19, 0x73, 0x4e, 0x62, 0xe1,
		0x16, 0xe4, 0x1c, 0x47, 0xa9, 0xd1, 0xa8, 0x3d,
	}
	data := []byte("Hello World")
	hash := MeowHash128(0, data)
	if !bytes.Equal(hash[:], expected) {
		t.Fail()
	}
}

func TestMeowHash256(t *testing.T) {
	expected := []uint8{
		0x8, 0x74, 0x51, 0x19, 0x73, 0x4e, 0x62, 0xe1,
		0x16, 0xe4, 0x1c, 0x47, 0xa9, 0xd1, 0xa8, 0x3d,
		0xa, 0xa3, 0x86, 0xa8, 0x4e, 0xf3, 0xb2, 0x2d,
		0xb, 0x3e, 0x3e, 0x67, 0x59, 0x73, 0x4c, 0x2d,
	}
	data := []byte("Hello World")
	hash := MeowHash256(0, data)
	if !bytes.Equal(hash[:], expected) {
		t.Fail()
	}
}

func TestMeowHash512(t *testing.T) {
	expected := []uint8{
		0x8, 0x74, 0x51, 0x19, 0x73, 0x4e, 0x62, 0xe1,
		0x16, 0xe4, 0x1c, 0x47, 0xa9, 0xd1, 0xa8, 0x3d,
		0xa, 0xa3, 0x86, 0xa8, 0x4e, 0xf3, 0xb2, 0x2d,
		0xb, 0x3e, 0x3e, 0x67, 0x59, 0x73, 0x4c, 0x2d,
		0x5c, 0x63, 0xc3, 0xb2, 0xef, 0x40, 0xef, 0x99,
		0xc3, 0x76, 0xa0, 0xe5, 0xa3, 0xf5, 0x73, 0x7b,
		0x11, 0x7c, 0x23, 0x91, 0xbd, 0x5c, 0x2a, 0x71,
		0xf6, 0x3f, 0xc1, 0xfd, 0xcc, 0x7c, 0xf4, 0xe6,
	}
	data := []byte("Hello World")
	hash := MeowHash512(0, data)
	if !bytes.Equal(hash[:], expected) {
		t.Fail()
	}
}
